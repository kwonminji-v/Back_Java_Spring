forword
web container 차원에서의 페이지 이동, 실제로 웹 브라우저는 다른 페이지로 이동했는지 알 수 없다.
(예시로 보면 고객은 상담원이 누구한테 물어봤는지 알 수 없는 것.)

웹 브라우저에는 최초로 호출한 URL만 표시되고, 이동한 페이지의 URL 정보는 볼 수가 없다. 
(고객은 123번으로만 전화했기 때문에 알 수가 없다.)

동일한 web containe에 있는 페이지로만 이동 가능하다.

현재 실행중인 페이지와 forwar에 의해 호출될 페이지는 request, response 객체를 공유한다.
(고객이 요청한 문의사항은 고객이 전화를 끊을 때까지 유효하다.)

forward 방식은 다음 이동한 URL로 요청정보를 그대로 전달한다.
말 그대로 forward(건네주기)하는 것이다.
그렇기 때문에 사용자가 최초로 요청한 요청정보는 다음 URL 에서도 유효하다.

redirec의 경우 최초 요청을 받은 URL1에서 클라이언트에 redirec할 URL2를 리턴하고, 클라이언트에게 전혀 새로운 요청을 생성하여 URL2에 다시 요청을 보낸다.
따라서 처음 보냈던 최초의 요청정보는 더이상 유효하지 않게 된다. 

최종적으로 정리하자면 redirec와 forwar의 차이는 크게 두가지로 나눌 수 있다.
첫째, URL의 변화여부 (변화 0 -> redirect, 변화 x -> forward)
둘째, 객체의 재사용 여부 (재사용 0 -> forward, 재사용 x -> redirect)

예를들어 게시판 애플리케이션을 작성한다고 해보자.
사용자가 요청정보를 이용하여 글쓰기 기능을 수행하는 CGI(common gateway interface)가 있다면, 이 CGI 응답 페이지는 forwar와 redirect 중 어느것을 사용할까?
정답은 redirec이다. 

사용자가 실수 혹은 고의로 글쓰기 CGI 응답페이지에서 새로고침을 누르면 forword의 경우 요청정보가 그대로 살아있기 때문에 똑같은 글이 여러번 등록될 수도 있다.
하지만 redirect의 경우 처음 글을 작성할 대 보냈던 요청정보는 존재 하지 않는다.
또한 글쓰기 기능을 하는 URL1이 아닌 URL2로 요청을 보내기 때문에 글쓰기가 여러번 수행되지 않는다. 

즉) 시스템(session, DB)에 변화가 생기는 요청 (로그인, 회원가입, 글쓰기)의 경우 redirect 방식으로 응답하는 것이 바람직하며
시스템에 변화가 생기지 않는 단순조회(리스트보기, 검색)의 경우 forward 방식으로 응답하는게 바람직하다.
